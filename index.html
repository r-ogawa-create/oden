<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>おでん的アルゴリズム | 優秀なおでんを作ろう！</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            odenCream: "#fff7ed",
            odenBrown: "#d9a066",
            odenSky: "#cfe8ff",
            odenMint: "#cde7d8",
            odenPink: "#f8d7e3",
          },
          animation: {
            float: "float 4s ease-in-out infinite",
            steam: "steam 3s ease-in-out infinite",
          },
          keyframes: {
            float: {
              "0%, 100%": { transform: "translate3d(0, 0px, 0)" },
              "50%": { transform: "translate3d(0, -8px, 0)" },
            },
            steam: {
              "0%": { opacity: 0.2, transform: "translateY(0) scale(1)" },
              "50%": { opacity: 0.6, transform: "translateY(-12px) scale(1.05)" },
              "100%": { opacity: 0, transform: "translateY(-24px) scale(0.95)" },
            },
          },
        },
      },
    };
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: "M PLUS Rounded 1c", system-ui, -apple-system, BlinkMacSystemFont,
        "Segoe UI", sans-serif;
      background: linear-gradient(160deg, #fff7ed 0%, #cfe8ff 100%);
    }
  </style>
</head>

<body class="min-h-screen text-slate-800">
  <div id="app-root" class="max-w-6xl mx-auto py-10 px-4 sm:px-6 lg:px-8"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"
    integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    // ========================== ヘルパー定数とユーティリティ ==========================
    const TEMPERATURE_STEPS = 8;
    const HEAT_LEVEL_LABELS = ["弱", "中", "強"];
    const MODE_LABELS = [
      { id: "fullAuto", label: "ランダム・オート", description: "温度や条件も勝手に変化しながら自動で世代交代" },
      { id: "randomManual", label: "ランダム・手動", description: "世代を進めるたびに条件がランダムで変動" },
      { id: "manualOnly", label: "全手動", description: "条件は固定、進行も自分のタイミングで" },
      { id: "steadyAuto", label: "手動・オート", description: "設定値は固定で自動進行" },
    ];

    let individualIdCounter = 0;

    /**
     * ユニークIDを生成する簡易ヘルパー。
     */
    const nextIndividualId = () => {
      individualIdCounter += 1;
      return `oden-${individualIdCounter}`;
    };

    /**
     * 配列の境界を守りつつ値を丸めるユーティリティ。
     */
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

    /**
     * 火加減ラベルをベース温度へ変換する。
     */
    const heatLevelToTemperature = (level) => {
      switch (level) {
        case "弱":
          return 68;
        case "中":
          return 80;
        case "強":
          return 92;
        default:
          return 78;
      }
    };

    /**
     * 温度推移（遺伝子）を生成する。
     * ぷるぷるした大根のゆらぎを表現するため、緩やかな揺らぎを加える。
     */
    const createTemperatureProfile = (baseTemperature) => {
      const profile = [];
      for (let i = 0; i < TEMPERATURE_STEPS; i += 1) {
        const drift = (Math.random() - 0.5) * 6;
        const trend = ((i / TEMPERATURE_STEPS) - 0.5) * (Math.random() * 6);
        const value = clamp(baseTemperature + drift + trend, 55, 98);
        profile.push(Number(value.toFixed(2)));
      }
      return profile;
    };

    /**
     * 個体を初期化する。必要に応じてベース温度を指定。
     */
    const createRandomIndividual = (settings, overrides = {}) => {
      const profileBase = overrides.baseTemperature ?? settings.baseTemperature;
      return evaluateIndividual({
        id: nextIndividualId(),
        generationBorn: overrides.generationBorn ?? 0,
        genes: {
          temperatureProfile: createTemperatureProfile(profileBase),
        },
        collapsed: false,
        miracle: false,
        notes: [],
      }, settings);
    };

    /**
     * 突然変異を適用する。
     * 突然変異が起こると高確率で崩壊するが、低確率で奇跡的な染み込みが発生する。
     */
    const mutateIndividual = (individual, mutationRate) => {
      const mutated = {
        ...individual,
        notes: [...(individual.notes ?? [])],
        genes: {
          temperatureProfile: [...individual.genes.temperatureProfile],
        },
      };

      const mutationThreshold = mutationRate / 100;
      if (Math.random() < mutationThreshold) {
        mutated.notes.push("突然変異発生");
        if (Math.random() < 0.85) {
          mutated.collapsed = true;
          mutated.notes.push("突然変異で崩壊");
        } else {
          mutated.miracle = true;
          mutated.notes.push("奇跡的な染み込みボーナス");
          mutated.genes.temperatureProfile = mutated.genes.temperatureProfile.map((temp) => clamp(temp + (Math.random() - 0.5) * 4, 55, 99));
        }
      } else {
        // 微小な環境ノイズで温度プロファイルをわずかに揺らす。
        mutated.genes.temperatureProfile = mutated.genes.temperatureProfile.map((temp) =>
          clamp(temp + (Math.random() - 0.5) * 2.5, 55, 99)
        );
      }

      return mutated;
    };

    /**
     * 親の温度プロファイルを交叉して子を作る。
     */
    const crossoverParents = (parentA, parentB) => {
      const profileA = parentA.genes.temperatureProfile;
      const profileB = parentB.genes.temperatureProfile;
      const length = Math.min(profileA.length, profileB.length);
      const pivot = Math.floor(length / 2);
      const childProfile = [];

      for (let i = 0; i < length; i += 1) {
        const base = i < pivot ? profileA[i] : profileB[i];
        const partner = i < pivot ? profileB[i] : profileA[i];
        const value = ((base + partner) / 2) + (Math.random() - 0.5) * 3.5;
        childProfile.push(clamp(value, 55, 98));
      }

      return childProfile;
    };

    /**
     * 個体を評価する。染み込み率と形保持率、崩壊チェックを計算。
     */
    const evaluateIndividual = (individual, settings) => {
      const profile = individual.genes.temperatureProfile;
      const averageTemp = profile.reduce((acc, temp) => acc + temp, 0) / profile.length;
      const maxTemp = Math.max(...profile);
      const minTemp = Math.min(...profile);
      const broth = settings.brothIntensity;
      const cookTime = settings.cookTime;
      const timePerSegment = cookTime / profile.length;
      const highTempSegments = profile.filter((temp) => temp >= 80).length;
      const highTempRatio = highTempSegments / profile.length;

      let soak = Math.min(1, (cookTime / 60) * 0.6 + (averageTemp / 100) * 0.4);
      soak *= 0.55 + (broth / 200);
      let shape = 1 - Math.max(0, (averageTemp - settings.baseTemperature) / 140);
      shape -= highTempRatio * 0.25;
      shape -= Math.max(0, (maxTemp - 92) / 80);
      shape = clamp(shape, 0, 1);

      let collapseChance = 0;
      if (averageTemp >= 80 && cookTime >= 15) {
        collapseChance += 0.5;
      }
      if (maxTemp >= 95) {
        collapseChance += 0.2;
      }
      if (cookTime >= 45) {
        collapseChance += 0.15;
      }
      if (minTemp <= 60) {
        soak *= 0.9; // 温度が低すぎると染み込みが遅い。
      }

      const notes = [...(individual.notes ?? [])];
      let collapsed = individual.collapsed;
      let miracle = individual.miracle;

      if (!collapsed && Math.random() < collapseChance) {
        collapsed = true;
        notes.push("煮込み過ぎで崩壊");
      }

      if (collapsed) {
        shape = 0;
        soak = clamp(soak * 0.4, 0, 1);
      }

      if (miracle) {
        soak = clamp(soak + 0.2, 0, 1);
        shape = clamp(shape + 0.1, 0, 1);
      }

      const fitness = Number((soak * shape).toFixed(4));

      return {
        ...individual,
        collapsed,
        miracle,
        notes,
        stats: {
          soak,
          shape,
          averageTemp,
          maxTemp,
          minTemp,
          highTempRatio,
          brothIntensity: broth,
          cookTime,
          timePerSegment,
        },
        fitness,
      };
    };

    /**
     * 世代全体の概要をまとめる。
     */
    const summarizePopulation = (population, settings, generationNumber, meta = {}) => {
      const averageSoak =
        population.reduce((acc, individual) => acc + individual.stats.soak, 0) /
        (population.length || 1);
      const averageShape =
        population.reduce((acc, individual) => acc + individual.stats.shape, 0) /
        (population.length || 1);
      const averageFitness =
        population.reduce((acc, individual) => acc + individual.fitness, 0) /
        (population.length || 1);

      const sorted = [...population].sort((a, b) => b.fitness - a.fitness);
      const bestIndividual = sorted[0] ?? null;

      return {
        generation: generationNumber,
        averageSoak,
        averageShape,
        averageFitness,
        bestIndividual,
        heatLevel: settings.heatLevel,
        brothIntensity: settings.brothIntensity,
        cookTime: settings.cookTime,
        mode: meta.mode ?? "",
        label: meta.label ?? "",
      };
    };

    /**
     * 1世代分のシミュレーションを実行する。
     */
    const simulateGeneration = (population, settings, mutationRate, targetSize, generationNumber) => {
      const evaluatedPopulation = population.map((individual) =>
        evaluateIndividual(
          {
            ...individual,
            notes: [],
          },
          settings
        )
      );

      const sortedCurrent = [...evaluatedPopulation].sort((a, b) => b.fitness - a.fitness);
      const parentPool = sortedCurrent.slice(
        0,
        Math.max(2, Math.ceil(sortedCurrent.length * 0.15))
      );

      const nextGeneration = [];
      const eliteCount = Math.max(1, Math.floor(targetSize * 0.1));

      for (let i = 0; i < eliteCount && i < sortedCurrent.length; i += 1) {
        const eliteSource = sortedCurrent[i];
        const eliteClone = evaluateIndividual(
          {
            id: nextIndividualId(),
            generationBorn: generationNumber,
            genes: {
              temperatureProfile: [...eliteSource.genes.temperatureProfile],
            },
            collapsed: false,
            miracle: false,
            notes: ["エリート保持"],
          },
          settings
        );
        nextGeneration.push(eliteClone);
      }

      while (nextGeneration.length < targetSize) {
        const parentA = parentPool[Math.floor(Math.random() * parentPool.length)];
        const parentB = parentPool[Math.floor(Math.random() * parentPool.length)];
        const childProfile = crossoverParents(parentA, parentB);
        let child = {
          id: nextIndividualId(),
          generationBorn: generationNumber,
          genes: {
            temperatureProfile: childProfile,
          },
          collapsed: false,
          miracle: false,
          notes: ["交叉子"],
        };

        child = mutateIndividual(child, mutationRate);
        child = evaluateIndividual(child, settings);
        nextGeneration.push(child);
      }

      const summary = summarizePopulation(nextGeneration, settings, generationNumber, {
        mode: settings.modeLabel ?? "",
      });

      const sortedNext = [...nextGeneration].sort((a, b) => b.fitness - a.fitness);
      const bestIndividual = sortedNext[0] ?? null;

      return {
        population: nextGeneration,
        summary,
        bestIndividual,
        parentPool,
      };
    };

    /**
     * ランダムに次のパラメータセットを生成。
     */
    const createRandomSettingsSnapshot = () => {
      const randomHeatLevel = HEAT_LEVEL_LABELS[Math.floor(Math.random() * HEAT_LEVEL_LABELS.length)];
      return {
        heatLevel: randomHeatLevel,
        cookTime: Math.floor(10 + Math.random() * 50),
        brothIntensity: Math.floor(40 + Math.random() * 60),
      };
    };

    // ========================== プレゼンテーション用コンポーネント ==========================

    const Badge = ({ children }) => (
      <span className="inline-flex items-center px-3 py-1 rounded-full bg-odenMint text-slate-700 text-sm font-medium shadow-sm">
        {children}
      </span>
    );

    /**
     * シンプルな折れ線グラフ。SVGで自前描画する。
     */
      const LineChart = ({ data, metricKey, color, title, maxGeneration }) => {
        const width = 420;
        const height = 240;
        const padding = 50;

      if (!data || data.length === 0) {
        return (
          <div className="bg-white/70 border border-white/60 rounded-3xl pr-8 py-8 pl-14 shadow-sm">
            <h3 className="font-semibold text-lg text-slate-700 mb-2">{title}</h3>
            <p className="text-sm text-slate-500">データがまだありません。</p>
          </div>
        );
      }

      const points = data.map((entry, index) => {
        const x =
          padding +
          (index / Math.max(1, data.length - 1)) * (width - padding * 2);
        const value = clamp(entry[metricKey] ?? 0, 0, 1);
        const y = height - padding - value * (height - padding * 2);
        return `${x},${y}`;
      });

      const axisY = [];
      for (let i = 0; i <= 5; i += 1) {
        axisY.push({
          label: `${i * 20}%`,
          y: height - padding - (i / 5) * (height - padding * 2),
        });
      }

      return (
        <div className="bg-white/75 border border-white/60 rounded-3xl pr-8 py-8 pl-14 shadow-sm">
          <h3 className="font-semibold text-lg text-slate-700 mb-4">{title}</h3>
          <svg width={width} height={height} className="w-full">
            <line
              x1={padding}
              y1={height - padding}
              x2={width - padding}
              y2={height - padding}
              stroke="#cbd5f5"
              strokeWidth="1"
            />
            <line
              x1={padding}
              y1={padding}
              x2={padding}
              y2={height - padding}
              stroke="#cbd5f5"
              strokeWidth="1"
            />
            {axisY.map((axis) => (
              <g key={axis.label}>
                <line
                  x1={padding}
                  y1={axis.y}
                  x2={width - padding}
                  y2={axis.y}
                  stroke="#e5e7f3"
                  strokeWidth="0.5"
                />
                <text
                  x={padding - 8}
                  y={axis.y + 4}
                  textAnchor="end"
                  fontSize="10"
                  fill="#6b7280"
                >
                  {axis.label}
                </text>
              </g>
            ))}
            <polyline
              fill="none"
              stroke={color}
              strokeWidth="3"
              strokeLinejoin="round"
              strokeLinecap="round"
              points={points.join(" ")}
            />
            {points.map((point, index) => {
              const [x, y] = point.split(",").map(Number);
              return (
                <circle
                  key={index}
                  cx={x}
                  cy={y}
                  r={4}
                  fill="#fff"
                  stroke={color}
                  strokeWidth="2"
                />
              );
            })}
            {(() => {
              const maxGenValue =
                maxGeneration ??
                data[data.length - 1]?.generation ??
                data.length;
              const intervalBase = Math.max(1, Math.floor((maxGenValue || 1) / 10));
              const labels = [];
              data.forEach((entry, index) => {
                const generationValue = entry.generation ?? index;
                const shouldLabel =
                  generationValue % intervalBase === 0 || index === data.length - 1;
                if (!shouldLabel) {
                  return;
                }
                const x =
                  padding +
                  (index / Math.max(1, data.length - 1)) * (width - padding * 2);
                labels.push(
                  <text
                    key={`gen-label-${generationValue}`}
                    x={x}
                    y={height - padding + 24}
                    textAnchor="middle"
                    fontSize="10"
                    fill="#6b7280"
                  >
                    {generationValue}
                  </text>
                );
              });
              return labels;
            })()}
          </svg>
          <div className="flex justify-end text-xs text-slate-500 mt-2">
            <span>世代</span>
          </div>
        </div>
      );
    };

    /**
     * ベスト個体をゆるかわに表示する。
     */
    const RadishPot = ({ individual, generation, topRecords }) => {
      const percentText = (value) => `${(value * 100).toFixed(1)}%`;
      const soakPercent = individual ? percentText(individual.stats.soak) : "0.0%";
      const shapePercent = individual ? percentText(individual.stats.shape) : "0.0%";
      const collapsed = individual?.collapsed;

      return (
        <div className="relative bg-gradient-to-b from-odenSky/90 to-white/80 border border-white rounded-3xl p-6 shadow-lg overflow-hidden">
          <div className="absolute inset-x-8 bottom-4 h-4 bg-gradient-to-b from-odenBrown/60 to-odenBrown/90 rounded-full blur-sm"></div>
          <div className="relative flex items-center justify-center">
            <div className="absolute -top-6 flex space-x-2">
              <div className="w-3 h-10 bg-white/70 rounded-full animate-steam"></div>
              <div
                className="w-3 h-14 bg-white/60 rounded-full animate-steam"
                style={{ animationDelay: "0.7s" }}
              ></div>
              <div
                className="w-3 h-12 bg-white/65 rounded-full animate-steam"
                style={{ animationDelay: "1.4s" }}
              ></div>
            </div>
            <div className="relative w-48 h-48 rounded-full bg-odenMint/90 border-4 border-odenMint/60 shadow-inner flex items-center justify-center">
              <div className="absolute inset-4 bg-white/80 rounded-full border-4 border-white animate-float shadow-md flex flex-col items-center justify-center">
                <div className="w-16 h-20 bg-gradient-to-b from-odenCream to-odenBrown/20 rounded-full border border-white/70 shadow-inner"></div>
                <div className="mt-3 text-xs text-slate-500 font-semibold">
                  {collapsed ? "ぐしゃ…" : "しっとり"}
                </div>
              </div>
            </div>
          </div>
          <div className="mt-6 text-center space-y-1">
            <Badge>第{generation}世代のベスト大根</Badge>
            <p className="text-sm text-slate-500">
              染み込み {soakPercent} / 形 {shapePercent}
            </p>
            {individual?.notes?.length ? (
              <div className="text-xs text-slate-400">
                {individual.notes.join(" / ")}
              </div>
            ) : (
              <div className="text-xs text-slate-400">静かに煮込み中…</div>
            )}
          </div>
          <div className="mt-5 bg-white/70 border border-white rounded-2xl px-5 py-4 shadow-inner">
            <h4 className="text-sm font-semibold text-slate-600 mb-3 text-center">ベスト大根ランキング</h4>
            {topRecords && topRecords.length > 0 ? (
              <ul className="space-y-2 text-xs text-slate-600">
                {topRecords.map((record, index) => (
                  <li
                    key={`${record.generation}-${record.fitness}-${index}`}
                    className="flex items-center justify-between bg-white/80 rounded-xl px-3 py-2 shadow-sm"
                  >
                    <span className="font-semibold text-slate-500">{index + 1}位</span>
                    <span className="text-slate-600">第{record.generation}世代</span>
                    <span className="text-odenBrown font-semibold">
                      染み込み {percentText(record.soak)} / 形 {percentText(record.shape)}
                    </span>
                  </li>
                ))}
              </ul>
            ) : (
              <p className="text-xs text-slate-400 text-center">ランキングデータを集計中です…</p>
            )}
          </div>
        </div>
      );
    };

    /**
     * 温度のタイムラインを簡易的に描画。
     */
      const TemperatureTimeline = ({ profile, cookTime }) => {
        if (!profile) {
          return (
            <div className="bg-white/75 border border-white rounded-3xl pr-6 py-6 pl-12 shadow-sm">
              <h3 className="font-semibold text-lg text-slate-700 mb-2">温度タイムライン</h3>
              <p className="text-sm text-slate-500">まだサンプルがありません。</p>
            </div>
          );
        }

        const width = 420;
        const height = 240;
        const padding = 50;
        const maxTemp = Math.max(100, ...profile);
        const minTemp = Math.min(40, ...profile);
        const barWidth = (width - padding * 2) / profile.length;
        const minuteStep = cookTime / profile.length;
        const minuteLabelInterval = Math.max(1, Math.floor(profile.length / 6));
        const axisTemps = [50, 60, 70, 80, 90, 100];

        return (
          <div className="bg-white/75 border border-white rounded-3xl pr-8 py-8 pl-14 shadow-sm">
            <h3 className="text-lg font-semibold text-slate-700 mb-4">温度タイムライン</h3>
            <svg width={width} height={height} className="w-full">
              <line
                x1={padding}
                y1={height - padding}
                x2={width - padding}
                y2={height - padding}
                stroke="#cbd5f5"
                strokeWidth="1"
              />
              <line
                x1={padding}
                y1={padding}
                x2={padding}
                y2={height - padding}
                stroke="#cbd5f5"
                strokeWidth="1"
              />
              {axisTemps.map((temp) => {
                const y =
                  height -
                  padding -
                  ((temp - minTemp) / (maxTemp - minTemp || 1)) * (height - padding * 2);
                return (
                  <g key={`temp-${temp}`}>
                    <line
                      x1={padding}
                      y1={y}
                      x2={width - padding}
                      y2={y}
                      stroke="#fde68a"
                      strokeDasharray="4 4"
                      strokeWidth="0.8"
                    />
                    <text
                      x={padding - 10}
                      y={y + 3}
                      textAnchor="end"
                      fontSize="10"
                      fill="#fb923c"
                    >
                      {temp}℃
                    </text>
                  </g>
                );
              })}
              <defs>
                <linearGradient id="heatGradient" x1="0" y1="1" x2="0" y2="0">
                  <stop offset="0%" stopColor="#fb923c" />
                  <stop offset="50%" stopColor="#f97316" />
                  <stop offset="100%" stopColor="#ef4444" />
                </linearGradient>
              </defs>
              {profile.map((temp, index) => {
                const barHeight =
                  ((temp - minTemp) / (maxTemp - minTemp || 1)) * (height - padding * 2);
                const x = padding + index * barWidth + barWidth * 0.1;
                const y = height - padding - barHeight;
                return (
                  <rect
                    key={`bar-${index}`}
                    x={x}
                    y={y}
                    width={barWidth * 0.8}
                    height={Math.max(4, barHeight)}
                    rx="6"
                    fill="url(#heatGradient)"
                    stroke="#f97316"
                    strokeWidth="0.7"
                  />
                );
              })}
              {profile.map((_, index) => {
                if (index % minuteLabelInterval !== 0 && index !== profile.length - 1) {
                  return null;
                }
                const x = padding + index * barWidth + barWidth * 0.5;
                let minuteMark = Math.round(index * minuteStep);
                if (index === profile.length - 1) {
                  minuteMark = cookTime;
                }
                return (
                  <text
                    key={`minute-${index}`}
                    x={x}
                    y={height - padding + 24}
                    textAnchor="middle"
                    fontSize="10"
                    fill="#6b7280"
                  >
                    {minuteMark}分
                  </text>
                );
              })}
            </svg>
            <div className="mt-3 text-xs text-slate-500 text-right">
              合計煮込み時間: {cookTime}分
            </div>
          </div>
        );
      };

    // ========================== メインアプリケーション ==========================

    const App = () => {
      const DEFAULTS = React.useMemo(
        () => ({
          populationSize: 24,
          generationLimit: 30,
          mutationRate: 3,
          brothIntensity: 70,
          heatLevel: "中",
          cookTime: 20,
          generationInterval: 3000,
          mode: "steadyAuto",
        }),
        []
      );

      const [populationSize, setPopulationSize] = React.useState(DEFAULTS.populationSize);
      const [generationLimit, setGenerationLimit] = React.useState(DEFAULTS.generationLimit);
      const [mutationRate, setMutationRate] = React.useState(DEFAULTS.mutationRate);
      const [brothIntensity, setBrothIntensity] = React.useState(DEFAULTS.brothIntensity);
      const [heatLevel, setHeatLevel] = React.useState(DEFAULTS.heatLevel);
      const [cookTime, setCookTime] = React.useState(DEFAULTS.cookTime);
      const [generationInterval, setGenerationInterval] = React.useState(DEFAULTS.generationInterval);
      const [mode, setMode] = React.useState(DEFAULTS.mode);

      const [isRunning, setIsRunning] = React.useState(false);
      const [generation, setGeneration] = React.useState(0);
      const [logEntries, setLogEntries] = React.useState([]);
      const [completionMessage, setCompletionMessage] = React.useState("");
        const [isShareOpen, setIsShareOpen] = React.useState(false);
        const [timelineSnapshot, setTimelineSnapshot] = React.useState(null);
        const [shareImageDataUrl, setShareImageDataUrl] = React.useState("");
        const [shareGeneratedAt, setShareGeneratedAt] = React.useState("");
        const [shareText, setShareText] = React.useState("");
        const [shareIntentUrl, setShareIntentUrl] = React.useState("");
        const [isGeneratingShare, setIsGeneratingShare] = React.useState(false);
        const [copyStatus, setCopyStatus] = React.useState("");
        const [sharePopupBlocked, setSharePopupBlocked] = React.useState(false);

        const intervalRef = React.useRef(null);
        const shareCardRef = React.useRef(null);

      /**
       * 初期状態を1度だけ計算して保持する。
       */
      const initialStateRef = React.useRef(null);
      if (!initialStateRef.current) {
        const baseSettings = {
          brothIntensity: DEFAULTS.brothIntensity,
          cookTime: DEFAULTS.cookTime,
          heatLevel: DEFAULTS.heatLevel,
          baseTemperature: heatLevelToTemperature(DEFAULTS.heatLevel),
          modeLabel: MODE_LABELS.find((item) => item.id === DEFAULTS.mode)?.label ?? "",
        };
        const population = Array.from({ length: DEFAULTS.populationSize }).map(() =>
          createRandomIndividual(baseSettings)
        );
        const summary = summarizePopulation(population, baseSettings, 0, {
          label: "初期集団",
          mode: baseSettings.modeLabel,
        });
        initialStateRef.current = {
          population,
          summary,
        };
      }

      const [population, setPopulation] = React.useState(initialStateRef.current.population);
      const [history, setHistory] = React.useState([initialStateRef.current.summary]);
      const [bestIndividual, setBestIndividual] = React.useState(initialStateRef.current.summary.bestIndividual);
      const [overallBest, setOverallBest] = React.useState({
        individual: initialStateRef.current.summary.bestIndividual,
        generation: initialStateRef.current.summary.generation ?? 0,
      });
      const [topRecords, setTopRecords] = React.useState(() => {
        const baseIndividual = initialStateRef.current.summary.bestIndividual;
        if (!baseIndividual) {
          return [];
        }
        return [
          {
            generation: initialStateRef.current.summary.generation ?? 0,
            soak: baseIndividual.stats.soak,
            shape: baseIndividual.stats.shape,
            fitness: baseIndividual.fitness,
          },
        ];
      });
      const populationRef = React.useRef(population);

      React.useEffect(() => {
        populationRef.current = population;
      }, [population]);

      /**
       * 現在の設定値をまとめて取得するヘルパー。
       */
      const buildCurrentSettings = React.useCallback(
        (override = {}) => ({
          brothIntensity: override.brothIntensity ?? brothIntensity,
          cookTime: override.cookTime ?? cookTime,
          heatLevel: override.heatLevel ?? heatLevel,
          baseTemperature: heatLevelToTemperature(override.heatLevel ?? heatLevel),
          modeLabel: MODE_LABELS.find((item) => item.id === mode)?.label ?? "",
        }),
        [brothIntensity, cookTime, heatLevel, mode]
      );

      /**
       * ログを追加し、古いものは圧縮する。
       */
      const pushLog = React.useCallback((message) => {
        setLogEntries((prev) => {
          const nextLog = [message, ...prev];
          return nextLog.slice(0, 12);
        });
      }, []);

      /**
       * 世代を進める本体処理。
       */
      const advanceGeneration = React.useCallback(
        (triggerSource) => {
          if (generation >= generationLimit) {
            setIsRunning(false);
            setCompletionMessage("設定した世代数に到達しました。初期化して再挑戦しましょう！");
            return;
          }

          let adjustedSettings = buildCurrentSettings();

          const isRandomMode = mode === "fullAuto" || mode === "randomManual";
          if (isRandomMode) {
            const randomSnapshot = createRandomSettingsSnapshot();
            setHeatLevel(randomSnapshot.heatLevel);
            setCookTime(randomSnapshot.cookTime);
            setBrothIntensity(randomSnapshot.brothIntensity);
            adjustedSettings = buildCurrentSettings(randomSnapshot);
            pushLog(
              `[条件変動] 火加減: ${randomSnapshot.heatLevel} / 煮込み: ${randomSnapshot.cookTime}分 / 出汁: ${randomSnapshot.brothIntensity}%`
            );
          }

          const nextGenerationNumber = generation + 1;
          const simulationResult = simulateGeneration(
            populationRef.current,
            adjustedSettings,
            mutationRate,
            populationSize,
            nextGenerationNumber
          );

          setPopulation(simulationResult.population);

          setGeneration(nextGenerationNumber);
          setBestIndividual(simulationResult.bestIndividual);
          setTimelineSnapshot({
            profile: simulationResult.bestIndividual?.genes.temperatureProfile ?? null,
            cookTime: adjustedSettings.cookTime,
            generation: nextGenerationNumber,
          });
          setHistory((prev) => [...prev, simulationResult.summary].slice(-60));
          setOverallBest((prev) => {
            const prevFitness = prev?.individual?.fitness ?? -Infinity;
            const currentFitness = simulationResult.bestIndividual?.fitness ?? -Infinity;
            if (currentFitness > prevFitness) {
              return {
                individual: simulationResult.bestIndividual,
                generation: nextGenerationNumber,
              };
            }
            return prev;
          });
          if (simulationResult.bestIndividual) {
            setTopRecords((prev) => {
              const withoutCurrentGen = prev.filter(
                (entry) => entry.generation !== nextGenerationNumber
              );
              const nextRecords = [
                ...withoutCurrentGen,
                {
                  generation: nextGenerationNumber,
                  soak: simulationResult.bestIndividual.stats.soak,
                  shape: simulationResult.bestIndividual.stats.shape,
                  fitness: simulationResult.bestIndividual.fitness,
                },
              ]
                .sort((a, b) => b.fitness - a.fitness)
                .slice(0, 5);
              return nextRecords;
            });
          }

          const logMessage = `[第${nextGenerationNumber}世代] 平均染み込み ${(simulationResult.summary.averageSoak * 100).toFixed(1)}% / 形 ${(simulationResult.summary.averageShape * 100).toFixed(1)}%`;
          pushLog(logMessage);

          if (nextGenerationNumber >= generationLimit) {
            setIsRunning(false);
            setCompletionMessage("最終世代に到達しました。結果を確認してシェアしてみよう！");
          }
        },
        [buildCurrentSettings, generation, generationLimit, mode, mutationRate, populationSize, pushLog]
      );

      /**
       * 自動進行のインターバル制御。
       */
      React.useEffect(() => {
        const isAutoMode = mode === "fullAuto" || mode === "steadyAuto";
        if (isRunning && isAutoMode) {
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
          }
          intervalRef.current = setInterval(() => {
            advanceGeneration("auto");
          }, generationInterval);
        } else {
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
          }
        }
        return () => {
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
          }
        };
      }, [advanceGeneration, generationInterval, isRunning, mode]);

      /**
       * 初期化ボタン用の処理。
       */
      const handleReset = () => {
        const settings = buildCurrentSettings();
        const newPopulation = Array.from({ length: populationSize }).map(() =>
          createRandomIndividual(settings)
        );
        const summary = summarizePopulation(newPopulation, settings, 0, {
          label: "初期集団",
          mode: settings.modeLabel,
        });

        setPopulation(newPopulation);
        setBestIndividual(summary.bestIndividual);
        setHistory([summary]);
        setGeneration(0);
        setLogEntries([]);
        setCompletionMessage("");
        setTimelineSnapshot({
          profile: summary.bestIndividual?.genes.temperatureProfile ?? null,
          cookTime: settings.cookTime,
          generation: 0,
        });
        setIsRunning(false);
        pushLog("[初期化] 新しいおでん集団を仕込みました！");
        setOverallBest({
          individual: summary.bestIndividual,
          generation: 0,
        });
        if (summary.bestIndividual) {
          setTopRecords([
            {
              generation: 0,
              soak: summary.bestIndividual.stats.soak,
              shape: summary.bestIndividual.stats.shape,
              fitness: summary.bestIndividual.fitness,
            },
          ]);
        } else {
          setTopRecords([]);
        }
      };

      /**
       * スクリーンショット保存。
       */
      const handleScreenshot = async () => {
        if (!window.html2canvas) {
          alert("スクリーンショット機能が利用できません。");
          return;
        }
        const target = document.getElementById("app-root");
        const canvas = await window.html2canvas(target, {
          backgroundColor: "#fff7ed",
          windowWidth: document.documentElement.scrollWidth,
          windowHeight: document.documentElement.scrollHeight,
        });
        const link = document.createElement("a");
        link.download = `oden-gen-${generation}.png`;
        link.href = canvas.toDataURL("image/png");
        link.click();
      };

      /**
       * ボタン押下での進行制御。
       */
      const handleStart = () => {
        if (generation >= generationLimit) {
          setCompletionMessage("既に最終世代まで進みました。初期化して再挑戦してください。");
          return;
        }
        setCompletionMessage("");
        setIsRunning(true);
        pushLog("[開始] おでんの進化を見守りましょう！");
        const isAutoMode = mode === "fullAuto" || mode === "steadyAuto";
        if (!isAutoMode) {
          pushLog("現在のモードでは手動で世代を進めてください。");
        } else {
          advanceGeneration("auto-start");
        }
      };

      const handleStop = () => {
        setIsRunning(false);
        pushLog("[停止] 火加減を見直しています。");
      };

      const currentModeMeta = MODE_LABELS.find((item) => item.id === mode);
      const topSoakPercent = ((overallBest?.individual?.stats?.soak ?? 0) * 100).toFixed(1);
      const topShapePercent = ((overallBest?.individual?.stats?.shape ?? 0) * 100).toFixed(1);
      const composeShareText = React.useCallback(() => {
        const intervalSeconds = (generationInterval / 1000).toFixed(1);
        const modeLabel = currentModeMeta?.label ?? mode;
        const bestGeneration = overallBest?.generation ?? generation;
        const bestSoak = ((overallBest?.individual?.stats?.soak ?? 0) * 100).toFixed(1);
        const bestShape = ((overallBest?.individual?.stats?.shape ?? 0) * 100).toFixed(1);
        return [
          "#おでん的アルゴリズム ベスト大根報告",
          `第${bestGeneration}世代 染み込み${bestSoak}% / 形${bestShape}%`,
          "設定まとめ:",
          `個体数 ${populationSize} / 最大世代数 ${generationLimit}`,
          `突然変異率 ${mutationRate}% / 出汁の濃さ ${brothIntensity}%`,
          `煮込み時間 ${cookTime}分 / 火加減 ${heatLevel}`,
          `世代進行間隔 ${intervalSeconds}秒 / 進行モード ${modeLabel}`,
        ].join("\n");
      }, [
        overallBest,
        generation,
        populationSize,
        generationLimit,
        mutationRate,
        brothIntensity,
        cookTime,
        heatLevel,
        generationInterval,
        currentModeMeta,
        mode,
      ]);

      const handleShareToX = React.useCallback(async () => {
        if (!window.html2canvas) {
          alert("共有画像の生成に必要なライブラリが読み込めていません。");
          return;
        }
        try {
          setSharePopupBlocked(false);
          setCopyStatus("");
          setShareImageDataUrl("");
          const timestamp = new Date().toLocaleString("ja-JP", { hour12: false });
          setShareGeneratedAt(timestamp);
          const shareMessage = composeShareText();
          setShareText(shareMessage);
          const intentUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareMessage)}`;
          setShareIntentUrl(intentUrl);
          setIsShareOpen(true);
          setIsGeneratingShare(true);
          await new Promise((resolve) =>
            requestAnimationFrame(() => requestAnimationFrame(resolve))
          );
          const target = shareCardRef.current;
          if (!target) {
            throw new Error("共有カードが見つかりませんでした。");
          }
          const canvas = await window.html2canvas(target, {
            backgroundColor: "#fff7ed",
            scale: Math.max(2, window.devicePixelRatio || 1),
            useCORS: true,
          });
          const dataUrl = canvas.toDataURL("image/png");
          setShareImageDataUrl(dataUrl);
          const downloadLink = document.createElement("a");
          downloadLink.href = dataUrl;
          downloadLink.download = `oden-share-gen-${generation}.png`;
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
          const popup = window.open(intentUrl, "_blank", "noopener,noreferrer");
          if (!popup) {
            setSharePopupBlocked(true);
          }
        } catch (error) {
          console.error(error);
          alert("X共有の準備中にエラーが発生しました。再度お試しください。");
        } finally {
          setIsGeneratingShare(false);
        }
      }, [composeShareText, generation, shareCardRef]);

      const handleCopyShareText = React.useCallback(async () => {
        if (!shareText) {
          return;
        }
        try {
          await navigator.clipboard.writeText(shareText);
          setCopyStatus("コピーしました");
          setTimeout(() => setCopyStatus(""), 2000);
        } catch (error) {
          console.error(error);
          setCopyStatus("コピーできませんでした");
        }
      }, [shareText]);

      const handleDownloadShareImage = React.useCallback(() => {
        if (!shareImageDataUrl) {
          return;
        }
        const link = document.createElement("a");
        link.href = shareImageDataUrl;
        link.download = `oden-share-gen-${generation}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }, [shareImageDataUrl, generation]);
      const shareModeLabel = currentModeMeta?.label ?? mode;
      const shareIntervalSeconds = (generationInterval / 1000).toFixed(1);
      const bestGenerationForShare = overallBest?.generation ?? generation;
      const percentDisplay = React.useCallback(
        (value) => `${(value * 100).toFixed(1)}%`,
        []
      );

      return (
        <>
          <div
            className="pointer-events-none fixed -left-[9999px] -top-[9999px] select-none"
            aria-hidden="true"
          >
            <div
              ref={shareCardRef}
              className="w-[660px] rounded-3xl border border-white bg-gradient-to-br from-odenSky/85 via-white/90 to-odenMint/70 px-8 py-8 text-slate-700 shadow-2xl"
            >
              <div className="flex items-start justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-slate-700">おでん的アルゴリズム</h2>
                  <p className="text-sm text-slate-500 mt-1">優秀なおでんを作ろう！</p>
                </div>
                <span className="text-sm font-semibold text-odenBrown">#おでん的アルゴリズム</span>
              </div>
              <div className="mt-6 grid md:grid-cols-2 gap-4">
                <div className="bg-white/85 rounded-2xl border border-white shadow-inner px-5 py-4">
                  <h3 className="text-sm font-semibold text-slate-600 mb-2">ベスト大根</h3>
                  <p className="text-lg font-bold text-slate-700">第{bestGenerationForShare}世代</p>
                  <p className="text-sm text-slate-600 mt-1">
                    染み込み {percentDisplay(overallBest?.individual?.stats?.soak ?? 0)} / 形{" "}
                    {percentDisplay(overallBest?.individual?.stats?.shape ?? 0)}
                  </p>
                  <p className="text-xs text-slate-500 mt-3">
                    世代進行中: 現在{generation}世代 / 個体数 {populationSize}
                  </p>
                </div>
                <div className="bg-white/85 rounded-2xl border border-white shadow-inner px-5 py-4">
                  <h3 className="text-sm font-semibold text-slate-600 mb-2">シミュレーション設定</h3>
                  <dl className="space-y-1 text-xs sm:text-sm text-slate-600">
                    <div className="flex justify-between gap-3">
                      <dt className="font-medium">個体数</dt>
                      <dd>{populationSize}</dd>
                    </div>
                    <div className="flex justify-between gap-3">
                      <dt className="font-medium">最大世代数</dt>
                      <dd>{generationLimit}</dd>
                    </div>
                    <div className="flex justify-between gap-3">
                      <dt className="font-medium">突然変異率</dt>
                      <dd>{mutationRate}%</dd>
                    </div>
                    <div className="flex justify-between gap-3">
                      <dt className="font-medium">出汁の濃さ</dt>
                      <dd>{brothIntensity}%</dd>
                    </div>
                    <div className="flex justify-between gap-3">
                      <dt className="font-medium">煮込み時間</dt>
                      <dd>{cookTime}分</dd>
                    </div>
                    <div className="flex justify-between gap-3">
                      <dt className="font-medium">火加減</dt>
                      <dd>{heatLevel}</dd>
                    </div>
                    <div className="flex justify-between gap-3">
                      <dt className="font-medium">世代進行間隔</dt>
                      <dd>{shareIntervalSeconds}秒</dd>
                    </div>
                    <div className="flex justify-between gap-3">
                      <dt className="font-medium">進行モード</dt>
                      <dd>{shareModeLabel}</dd>
                    </div>
                  </dl>
                </div>
              </div>
              <div className="mt-6 bg-white/85 rounded-2xl border border-white shadow-inner px-5 py-4">
                <h3 className="text-sm font-semibold text-slate-600 mb-2">ランキングTOP5</h3>
                {topRecords && topRecords.length > 0 ? (
                  <ol className="space-y-1 text-xs sm:text-sm text-slate-600">
                    {topRecords.map((record, index) => (
                      <li key={`${record.generation}-${record.fitness}-${index}`} className="flex justify-between gap-3">
                        <span className="font-semibold text-slate-500">{index + 1}位</span>
                        <span className="text-slate-600">第{record.generation}世代</span>
                        <span className="text-odenBrown font-semibold">
                          染み込み {percentDisplay(record.soak)} / 形 {percentDisplay(record.shape)}
                        </span>
                      </li>
                    ))}
                  </ol>
                ) : (
                  <p className="text-xs text-slate-400">ランキングデータを集計中です…</p>
                )}
              </div>
              <div className="mt-6 flex items-center justify-between text-xs text-slate-500">
                <span>進行モード: {shareModeLabel}</span>
                <span>生成日時: {shareGeneratedAt || "準備中"}</span>
              </div>
            </div>
          </div>
          <div className="space-y-8">
          <header className="bg-white/70 border border-white rounded-3xl px-8 py-7 shadow-lg flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
            <div>
              <h1 className="text-3xl font-bold text-slate-700">おでん的アルゴリズム</h1>
              <p className="text-slate-500 mt-1">〜遺伝的アルゴリズムから学ぶ優秀な味染み大根の作り方〜</p>
            </div>
            <div className="flex flex-col sm:flex-row gap-3 sm:items-center">
              <Badge>世代: {generation}</Badge>
              <Badge>個体数: {populationSize}</Badge>
              <Badge>突然変異: {mutationRate}%</Badge>
            </div>
          </header>

          <section className="grid lg:grid-cols-3 gap-6">
            <div className="lg:col-span-2 bg-white/75 border border-white rounded-3xl p-6 shadow-sm space-y-6">
              <h2 className="text-xl font-semibold text-slate-700">シミュレーション設定</h2>
              <div className="grid md:grid-cols-2 gap-6">
                <div>
                  <label className="block text-sm text-slate-500 mb-1">個体数</label>
                  <input
                    type="number"
                    min="6"
                    max="80"
                    value={populationSize}
                    onChange={(event) => setPopulationSize(Number(event.target.value))}
                    className="w-full rounded-2xl border border-slate-200 bg-white px-4 py-2 shadow-inner focus:outline-none focus:ring-2 focus:ring-odenMint"
                  />
                  <p className="text-xs text-slate-400 mt-1">個体数を変更したら「初期化」を押して反映します。</p>
                </div>
                <div>
                  <label className="block text-sm text-slate-500 mb-1">最大世代数</label>
                  <input
                    type="number"
                    min="5"
                    max="200"
                    value={generationLimit}
                    onChange={(event) => setGenerationLimit(Number(event.target.value))}
                    className="w-full rounded-2xl border border-slate-200 bg-white px-4 py-2 shadow-inner focus:outline-none focus:ring-2 focus:ring-odenMint"
                  />
                </div>
                <div>
                  <label className="block text-sm text-slate-500 mb-1 flex items-center justify-between">
                    <span>突然変異率</span>
                    <span className="text-xs">{mutationRate}%</span>
                  </label>
                  <input
                    type="range"
                    min="0"
                    max="20"
                    value={mutationRate}
                    onChange={(event) => setMutationRate(Number(event.target.value))}
                    className="w-full"
                  />
                </div>
                <div>
                  <label className="block text-sm text-slate-500 mb-1 flex items-center justify-between">
                    <span>出汁の濃さ</span>
                    <span className="text-xs">{brothIntensity}%</span>
                  </label>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    value={brothIntensity}
                    onChange={(event) => setBrothIntensity(Number(event.target.value))}
                    className="w-full"
                  />
                </div>
                <div>
                  <label className="block text-sm text-slate-500 mb-2">火加減</label>
                  <div className="flex gap-2">
                    {HEAT_LEVEL_LABELS.map((label) => (
                      <button
                        key={label}
                        onClick={() => setHeatLevel(label)}
                        className={
                          "flex-1 rounded-2xl px-3 py-2 text-sm font-semibold transition " +
                          (heatLevel === label
                            ? "bg-odenMint text-slate-700 shadow-inner"
                            : "bg-slate-100 text-slate-400 hover:bg-slate-200")
                        }
                      >
                        {label}
                      </button>
                    ))}
                  </div>
                </div>
                <div>
                  <label className="block text-sm text-slate-500 mb-1 flex items-center justify-between">
                    <span>煮込み時間（分）</span>
                    <span className="text-xs">{cookTime}分</span>
                  </label>
                  <input
                    type="range"
                    min="5"
                    max="120"
                    value={cookTime}
                    onChange={(event) => setCookTime(Number(event.target.value))}
                    className="w-full"
                  />
                </div>
                <div>
                  <label className="block text-sm text-slate-500 mb-1 flex items-center justify-between">
                    <span>世代進行間隔</span>
                    <span className="text-xs">{(generationInterval / 1000).toFixed(1)}秒</span>
                  </label>
                  <input
                    type="range"
                    min="100"
                    max="3000"
                    step="100"
                    value={generationInterval}
                    onChange={(event) => setGenerationInterval(Number(event.target.value))}
                    className="w-full"
                  />
                  <p className="text-xs text-slate-400 mt-1">自動モード時の進行スピードです（0.1〜3秒）。</p>
                </div>
                <div>
                  <label className="block text-sm text-slate-500 mb-1">進行モード</label>
                  <select
                    value={mode}
                    onChange={(event) => setMode(event.target.value)}
                    className="w-full rounded-2xl border border-slate-200 bg-white px-4 py-2 shadow-inner focus:outline-none focus:ring-2 focus:ring-odenMint"
                  >
                    {MODE_LABELS.map((item) => (
                      <option key={item.id} value={item.id}>
                        {item.label}
                      </option>
                    ))}
                  </select>
                  <p className="text-xs text-slate-400 mt-1">{currentModeMeta?.description}</p>
                </div>
              </div>
              <div className="flex flex-wrap gap-3">
                <button
                  onClick={handleStart}
                  className="rounded-2xl bg-odenMint px-4 py-3 text-sm font-semibold text-slate-700 shadow hover:bg-odenMint/90 transition"
                >
                  シミュレーション開始
                </button>
                <button
                  onClick={handleStop}
                  className="rounded-2xl bg-slate-200 px-4 py-3 text-sm font-semibold text-slate-600 shadow hover:bg-slate-300 transition"
                >
                  一時停止
                </button>
                <button
                  onClick={() => advanceGeneration("manual")}
                  className="rounded-2xl bg-odenSky px-4 py-3 text-sm font-semibold text-slate-700 shadow hover:bg-odenSky/90 transition"
                >
                  1世代進める
                </button>
                <button
                  onClick={handleReset}
                  className="rounded-2xl bg-white px-4 py-3 text-sm font-semibold text-slate-600 border border-slate-200 shadow hover:bg-slate-100 transition"
                >
                  初期化
                </button>
              </div>
              {completionMessage && (
                <div className="rounded-2xl bg-odenPink/50 border border-odenPink px-4 py-3 text-sm text-slate-600">
                  {completionMessage}
                </div>
              )}
            </div>

            <RadishPot individual={bestIndividual} generation={generation} topRecords={topRecords} />
          </section>

          <section className="grid lg:grid-cols-2 gap-6">
            <LineChart
              data={history}
              metricKey="averageSoak"
              color="#93c5fd"
              title="平均染み込み率の推移"
              maxGeneration={generationLimit}
            />
            <LineChart
              data={history}
              metricKey="averageShape"
              color="#f9a8d4"
              title="平均形保持率の推移"
              maxGeneration={generationLimit}
            />
          </section>

          <section className="grid lg:grid-cols-3 gap-6">
            <div className="lg:col-span-2 bg-white/75 border border-white rounded-3xl p-6 shadow-sm">
              <h3 className="text-lg font-semibold text-slate-700 mb-3">世代ログ</h3>
              <div className="space-y-2 max-h-72 overflow-y-auto pr-2">
                {logEntries.length === 0 ? (
                  <p className="text-sm text-slate-500">まだログはありません。開始すると状況が流れてきます。</p>
                ) : (
                  logEntries.map((entry, index) => (
                    <div key={index} className="rounded-2xl bg-slate-100/80 px-4 py-2 text-sm text-slate-600">
                      {entry}
                    </div>
                  ))
                )}
              </div>
            </div>
            <TemperatureTimeline
              profile={timelineSnapshot?.profile}
              cookTime={timelineSnapshot?.cookTime ?? cookTime}
            />
          </section>

          <section className="bg-white/80 border border-white rounded-3xl p-6 shadow-sm space-y-4">
            <h3 className="text-lg font-semibold text-slate-700">結果出力と共有</h3>
            <div className="flex flex-wrap gap-3">
              <button
                onClick={handleScreenshot}
                className="rounded-2xl bg-odenMint px-4 py-3 text-sm font-semibold text-slate-700 shadow hover:bg-odenMint/90 transition"
              >
                スクリーンショット保存
              </button>
              <button
                onClick={handleShareToX}
                disabled={isGeneratingShare}
                className={
                  "rounded-2xl px-4 py-3 text-sm font-semibold shadow transition " +
                  (isGeneratingShare
                    ? "bg-odenSky/60 text-slate-400 cursor-not-allowed"
                    : "bg-odenSky text-slate-700 hover:bg-odenSky/90")
                }
              >
                {isGeneratingShare ? "共有準備中…" : "Xに共有"}
              </button>
            </div>
            <p className="text-sm text-slate-500">
              ※共有ボタンで投稿用画像を自動生成し、Xの投稿ウィンドウを開きます。ダウンロードされた画像を添付して投稿してください。
            </p>
          </section>

          {!isRunning && generation >= generationLimit && (
            <section className="bg-odenPink/40 border border-odenPink/60 rounded-3xl p-6 shadow-inner">
              <h2 className="text-xl font-semibold text-slate-700 mb-2">最終結果</h2>
              <p className="text-sm text-slate-600 mb-4">
                ベスト大根は第{overallBest?.generation ?? 0}世代の染み込み{topSoakPercent}%、形{topShapePercent}%でした！
              </p>
              <button
                onClick={handleReset}
                className="rounded-2xl bg-white px-4 py-3 text-sm font-semibold text-slate-700 border border-white shadow hover:bg-slate-100 transition"
              >
                もう一度仕込み直す
              </button>
            </section>
          )}

          {isShareOpen && (
            <div className="fixed inset-0 bg-slate-800/30 backdrop-blur-sm flex items-center justify-center p-4 z-50">
              <div className="bg-white rounded-3xl p-6 shadow-xl max-w-xl w-full space-y-5">
                <div className="flex items-start justify-between gap-4">
                  <h3 className="text-lg font-semibold text-slate-700">X共有の準備</h3>
                  <button
                    onClick={() => setIsShareOpen(false)}
                    className="rounded-full bg-slate-100 text-slate-500 hover:bg-slate-200 px-3 py-1 text-sm font-semibold transition"
                  >
                    閉じる
                  </button>
                </div>
                {isGeneratingShare ? (
                  <p className="text-sm text-slate-600">共有画像を生成しています… 少々お待ちください。</p>
                ) : (
                  <>
                    <p className="text-sm text-slate-600">
                      Xの投稿ウィンドウを
                      {sharePopupBlocked ? "自動で開けませんでした。" : "開きました。"}
                      ダウンロードされた画像（oden-share-gen-{generation}.png）を添付して投稿してください。
                    </p>
                    {sharePopupBlocked && shareIntentUrl && (
                      <p className="text-xs text-rose-500">
                        ブラウザにポップアップがブロックされた可能性があります。下の「X投稿画面を開く」から再度アクセスしてください。
                      </p>
                    )}
                    {shareImageDataUrl ? (
                      <img
                        src={shareImageDataUrl}
                        alt="共有用プレビュー"
                        className="w-full rounded-2xl border border-slate-200 shadow-sm"
                      />
                    ) : (
                      <p className="text-xs text-slate-400">共有用画像がまだ生成されていません。</p>
                    )}
                    <div className="flex flex-wrap gap-3">
                      <button
                        onClick={handleDownloadShareImage}
                        disabled={!shareImageDataUrl}
                        className={
                          "rounded-2xl px-4 py-2 text-sm font-semibold transition " +
                          (shareImageDataUrl
                            ? "bg-odenMint text-slate-700 shadow hover:bg-odenMint/90"
                            : "bg-slate-200 text-slate-400 cursor-not-allowed")
                        }
                      >
                        画像を再ダウンロード
                      </button>
                      <a
                        href={shareIntentUrl || "#"}
                        target="_blank"
                        rel="noopener noreferrer"
                        className={
                          "rounded-2xl px-4 py-2 text-sm font-semibold transition " +
                          (shareIntentUrl
                            ? "bg-odenSky text-slate-700 shadow hover:bg-odenSky/90"
                            : "bg-slate-200 text-slate-400 cursor-not-allowed pointer-events-none")
                        }
                      >
                        X投稿画面を開く
                      </a>
                    </div>
                    <div>
                      <label className="block text-sm font-semibold text-slate-600 mb-2">投稿テキスト</label>
                      <textarea
                        value={shareText}
                        readOnly
                        className="w-full h-32 rounded-2xl border border-slate-200 bg-slate-50 px-3 py-2 text-sm text-slate-600 shadow-inner"
                      />
                      <div className="mt-2 flex items-center gap-3">
                        <button
                          onClick={handleCopyShareText}
                          className="rounded-2xl bg-slate-900 px-4 py-2 text-sm font-semibold text-white shadow hover:bg-slate-700 transition"
                        >
                          テキストをコピー
                        </button>
                        {copyStatus && <span className="text-xs text-slate-500">{copyStatus}</span>}
                      </div>
                    </div>
                  </>
                )}
              </div>
            </div>
          )}
        </div>
        </>
      );
    };

    ReactDOM.createRoot(document.getElementById("app-root")).render(<App />);
  </script>
</body>

</html>
